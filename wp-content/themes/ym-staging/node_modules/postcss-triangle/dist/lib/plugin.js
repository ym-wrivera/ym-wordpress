'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var plugin = 'postcss-triangle';
var errorContext = { plugin: plugin };
exports['default'] = _postcss2['default'].plugin(plugin, function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    if (typeof options.unitPrecision === 'undefined') {
        options.unitPrecision = 5;
    }
    return function (root) {
        root.walkRules(function (rule) {
            var isTriangle = false;
            var width = undefined;
            var height = undefined;
            var direction = undefined;
            rule.walkDecls('triangle', function (decl) {
                isTriangle = true;
                rule.walkDecls('width', function (d) {
                    width = parseLength(d.value);
                    d.value = '0';
                    d.moveBefore(decl);
                });
                if (!width) {
                    decl.cloneBefore({ prop: 'width', value: '0' });
                }
                rule.walkDecls('height', function (d) {
                    height = parseLength(d.value);
                    d.value = '0';
                    d.moveBefore(decl);
                });
                if (!height) {
                    decl.cloneBefore({ prop: 'height', value: '0' });
                }
                decl.cloneBefore({
                    prop: 'border-style',
                    value: 'solid'
                });
                decl.cloneBefore({
                    prop: 'border-color',
                    value: 'transparent'
                });
                var type = undefined;

                var _postcss$list$space = _postcss2['default'].list.space(decl.value);

                var _postcss$list$space2 = _slicedToArray(_postcss$list$space, 2);

                type = _postcss$list$space2[0];
                direction = _postcss$list$space2[1];

                if (!direction) {
                    direction = type;
                    if (!width) {
                        throw rule.error('Missing required width declaration', errorContext);
                    }
                    if (!height) {
                        throw rule.error('Missing required height declaration', errorContext);
                    }
                } else if (!/^(right-iso|equilateral)$/.test(type)) {
                    throw decl.error('Unsupported type: ' + type, errorContext);
                } else if (!width && !height) {
                    throw rule.error('Missing required width or height declaration', errorContext);
                } else if (width && height) {
                    throw rule.error(type + ' triangle cannot have both width and height', errorContext);
                } else {
                    var multiplier = type === 'right-iso' ? 0.5 : sinDegrees(60);
                    if (/^(pointing-(up|down))$/.test(direction)) {
                        width = width || {
                            value: height.value / multiplier,
                            unit: height.unit
                        };
                        height = height || {
                            value: width.value * multiplier,
                            unit: width.unit
                        };
                    } else {
                        width = width || {
                            value: height.value * multiplier,
                            unit: height.unit
                        };
                        height = height || {
                            value: width.value / multiplier,
                            unit: width.unit
                        };
                    }
                }
                if (!/^(pointing-(up|down|left|right))$/.test(direction)) {
                    throw decl.error('Unsupported direction: ' + direction + '.', errorContext);
                }
                decl.cloneBefore({
                    prop: 'border-width',
                    value: buildBorderWidth(width, height, direction)
                });
                decl.remove();
            });
            if (!isTriangle) {
                return;
            }
            var isColorDefined = false;
            rule.walkDecls('background-color', function (decl) {
                isColorDefined = true;
                var oppositeDirection = ({
                    up: 'bottom',
                    right: 'left',
                    down: 'top',
                    left: 'right'
                })[direction.split('-')[1]];
                decl.prop = 'border-' + oppositeDirection + '-color';
            });
            if (!isColorDefined) {
                throw rule.error('Missing required background-color declaration', errorContext);
            }
        });
    };
    function sinDegrees(angle) {
        return Math.sin(angle / 180 * Math.PI);
    }
    function parseLength(length) {
        var value = parseFloat(length);

        var _length$match = length.match(/([a-z]+)$/);

        var _length$match2 = _slicedToArray(_length$match, 2);

        var unit = _length$match2[1];

        return { value: value, unit: unit };
    }
    function stringifyLength(length) {
        var precision = Math.pow(10, options.unitPrecision);
        var rounded = Math.round(length.value * precision) / precision;
        return rounded + length.unit;
    }
    function buildBorderWidth(width, height, direction) {
        var hw = stringifyLength({
            value: width.value / 2,
            unit: width.unit
        });
        var hh = stringifyLength({
            value: height.value / 2,
            unit: height.unit
        });
        var w = stringifyLength(width);
        var h = stringifyLength(height);
        return ({
            up: '0 ' + hw + ' ' + h,
            right: hh + ' 0 ' + hh + ' ' + w,
            down: h + ' ' + hw + ' 0',
            left: hh + ' ' + w + ' ' + hh + ' 0'
        })[direction.split('-')[1]];
    }
});
module.exports = exports['default'];